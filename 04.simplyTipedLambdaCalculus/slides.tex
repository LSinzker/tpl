\documentclass{beamer}

\usepackage{busproofs}

\usepackage{amsmath}

\usefonttheme[onlymath]{serif}

\input{quotes}

\title{Types and Programming Languages} 
\subtitle{Simply Typed Lambda-Calculus}

\author{Rodrigo Bonif\'{a}cio}
\date{2017/09}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}

\begin{shadequote}[l]{Benjamin Pierce}
A language combining booleans with the 
primitives of the pure lambda-calculus. 
\end{shadequote} \pause

\begin{block}{\ldots plus a typing rules for}

\begin{itemize}
\item variables
\item abstractions
\item application
\item booleans and conditional (\textsc{If-Then-Else}) 
\end{itemize} \pause 

that maintain type safety and are not too 
conservative. \pause To achieve this goal, it is 
necessary to know what type a function expects as 
argument and what type it returns. 

\end{block}

\end{frame}

\begin{frame}[fragile] 
In the \emph{Simply Type Lambda-Calculus} the set of 
simple types is generated by the following grammar. 

\begin{verbatim}
 T ::= Bool 
     | T -> T
\end{verbatim} 

where the \texttt{$\rightarrow$} type constructor is 
\emph{right associative}, that is, 
$T_1 \rightarrow T_2 \rightarrow T_3$ stands for 
$T_1 \rightarrow (T_2 \rightarrow T_3)$. 

\end{frame}

\begin{frame}[fragile]
\frametitle{The type relation} 

We have two options in order to assign 
what type of arguments to expect\pause: 
we can annotate the lambda abstraction or 
infer the expected argument by analysing the 
body of the lambda expression. \pause

\begin{verbatim}
 t ::= x 
     | \x : T . t
     | t t
\end{verbatim}

In this way, it is necessary to consider a
sequence (the \emph{type environment} $\Gamma$) 
of tuples $x : T)$---denoting a variable  
and its corresponding type. 

\end{frame}

\begin{frame}

\begin{small}
\begin{block}{Rule for abstraction} 
\begin{prooftree}
\AxiomC{$\Gamma, x : T_1 \vdash t_2 : T_2$} 
\RightLabel{\quad (T-Abs)}
\UnaryInfC{$\Gamma \vdash \lambda x : T_1\ .\ t_2 : T_2 \rightarrow T_2$}
\end{prooftree}
\end{block} \pause

\begin{block}{Rule for variable} 
\begin{prooftree}
\AxiomC{$ x : T \in \Gamma$} 
\RightLabel{\quad (T-Var)}
\UnaryInfC{$\Gamma \vdash x : T$} 
\end{prooftree}
\end{block} \pause


\begin{block}{Rule for application} 
\begin{prooftree}
\AxiomC{$\Gamma \vdash t1 : T_{11} \rightarrow T_{12}$}
\AxiomC{$\Gamma \vdash t2 : T_{11}$}
\RightLabel{\quad (T-App)}
\BinaryInfC{$\Gamma\ t_1\ t_2 : T_{12}$} 
\end{prooftree}
\end{block}

\end{small}

\end{frame}

\begin{frame}

A discussion on soundness (type safety) is also presented in 
this chapter, considering several important lemmas, including: 

\begin{itemize}
\item weakening 
\item preservation of types under substitution
\end{itemize} 

\end{frame}

\begin{frame}
\frametitle{Curry-Howard Correspondence} 

In logics, it is quite common to use a 
set of inference rules to prove statements. 
Some simple examples of inference rules 
related to conjunction: 

%\column{.3\textwidth}
\begin{prooftree}
\AxiomC{$P$}
\AxiomC{$Q$}
\RightLabel{\quad (and introduction)}
\BinaryInfC{$P \wedge Q$}
\end{prooftree}


%\column{.3\textwidth}
\begin{prooftree}
\AxiomC{$P \wedge Q$}
\RightLabel{\quad (and elimination)}
\UnaryInfC{P}
\end{prooftree}


%\column{.3\textwidth}
\begin{prooftree}
\AxiomC{$P \wedge Q$}
\RightLabel{\quad (and elimination)}
\UnaryInfC{Q}
\end{prooftree}

%\end{columns}

\end{frame}

\begin{frame}

The typing rules for abstraction and 
application are also considered examples of 
introduction and elimination rules\pause, and  
there is a strong relation between constructive 
logics and type systems. This relation, briefly 
discussed in the TPL book, is known as the 
\emph{Curry-Howard Isomorphism}. \pause 

\begin{shadequote}[l]{Benjamin Pierce}
A proof of a proposition $P \supset Q$ in 
constructive logic can be viewed as a mechanical 
procedure that, given a proof of $P$, constructs a 
proof of $Q$. 
\end{shadequote}

\end{frame}

\begin{frame}
\begin{center}
\begin{tabular}{ll} \hline
Logic & Programming Languages \\ \hline \hline 
propositions & types \\
proposition $P \subset Q$ & type $p \rightarrow q$ \\
proposition $P \wedge Q$ & type $P \times Q$ \\
proof of proposition $P$ & term $t$ has type $P$ \\
proposition $P$ is provable & type $P$ is inhabited (by some term) \\ \hline
\end{tabular}
\end{center} \pause 

More about the Curry-Howard correspondence can be found  
in the book \emph{Computation and Deduction} (F. Pfenning). 
  
\end{frame} 
\begin{frame}
 \titlepage
\end{frame}
\end{document}
