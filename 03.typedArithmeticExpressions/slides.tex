\documentclass{beamer}

\usepackage{busproofs}

\usepackage{amsmath}

\usefonttheme[onlymath]{serif}

\input{quotes}

\title{Types and Programming Languages} 
\subtitle{Typed Arithmetic Expressions}

\author{Rodrigo Bonif\'{a}cio}
\date{2017/08}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}

Let's just remember our {\color{blue}Arithmetic Expression}
language. 

\end{frame}

\begin{frame}
\frametitle{Syntactic Forms} 

\begin{itemize}
\item boolean constants: \texttt{true}, \texttt{false}
\item conditional expressions
\item numeric constant: \texttt{zero}
\item arithmetic operators: \texttt{succ}, \texttt{pred}
\item testing operation: \texttt{isZero} 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Grammar} 

\begin{verbatim}
 Exp ::= true
         false 
         if Exp then Exp else Exp
         0
         succ Exp
         pred Exp
         iszero Exp
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
In this language, the results of evaluation
are terms of a particularly simple form: they will 
either evaluate to a value 

\begin{verbatim}
 v ::= true 
     | false 
     | nv

 nv ::= 0
      | succ nv 
\end{verbatim}

or else get {\color{blue}stuck} at some stage (by 
reaching a term like \texttt{pred false} for which 
no evaluation rule applies). 
\end{frame}

\begin{frame}
\begin{itemize}
\item Our goal is to design means to tell, without evaluating 
a term, that its evaluation will definitely not get stuck, 
by assigning a term $t$ to a given type $T$.  \pause 

\item {\color{blue}\ldots without evaluating a term} means that 
we shoud assign a type to a term {\color{blue}statically}, 
and thus we will follow a conservative approach, rejecting 
a program of the form \texttt{if true then 0 else false}---even though 
it won't get stuck. 
\end{frame}

\begin{frame}[fragile]
\frametitle{The Type Relation} 

\begin{block}{New syntactic forms}
\begin{verbatim} 
 T ::= Bool            type of booleans
     | Nat      type of natural numbers       
\end{verbatim}

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (T-Zero)}
\UnaryInfC{$0\ : Nat$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (T-True)}
\UnaryInfC{$true\ : Bool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (T-False)}
\UnaryInfC{$false\ : Bool$}
\end{prooftree}
\end{block}

\end{frame}

\begin{frame} 

\begin{prooftree}
\AxiomC{$t_1 : Bool$} 
\AxiomC{$t_2 : T$}
\AxiomC{$t_3 : T$}
\RightLabel{\quad (T-If)}
\TrinaryInfC{$false\ : Bool$}
\end{prooftree}

\begin{prooftreee}
\AxiomC{$t_1 : Nat$}
\RightLabel{\quad (T-Succ)}
\UnaryInfC{$succ\ t_1: Nat$}
\end{prooftree} 


\begin{prooftreee}
\AxiomC{$t_1 : Nat$}
\RightLabel{\quad (T-Succ)}
\UnaryInfC{$succ\ t_1: Nat$}
\end{prooftree} 


\begin{prooftreee}
\AxiomC{$t_1 : Nat$}
\RightLabel{\quad (T-Pred)}
\UnaryInfC{$pred\ t_1: Nat$}
\end{prooftree} 



\begin{prooftreee}
\AxiomC{$t_1 : Nat$}
\RightLabel{\quad (T-IsZero)}
\UnaryInfC{$iszero\ t_1: Bool$}
\end{prooftree} 

\end{frame}

\begin{frame}
\frametitle{Induction on terms} 

The inductive structure of expressions allow us 
to give inductive definitions of functions over 
the set of expressions. 

\begin{definition}{{\color{blue}The set of constants of an expression}}
\begin{eqnarray*}
Consts(true)         & = & \{true\}         \\
Consts(false)        & = & \{false\}        \\
Consts(0)            & = & {0}            \\ \pause 
Consts(succ\ t_1)    & = & Consts(t_1)    \\ 
Consts(pred\ t_1)    & = & Consts(t_1)    \\ 
Consts(iszero\ t_1)  & = & Consts(t_1)    \\ \pause 
Consts(if\ t_1 then\ t_2 else t_3) & = & Consts(t_1) \cup Consts(t_2) \cup Consts(t_3) \\  
\end{eqnarray*}

\end{definition} 
\end{frame}

\begin{frame}
\frametitle{Small step operational semantics}


\begin{shadequote}[l]{Benjamin Pierce}
\ldots An \emph{evaluation relation} on expressions, written 
as $t \rightarrow t'$ and pronounced ``$t$ evaluates to $t'$ in 
one step''. The intuition is that, if $t$ is the state of a 
computation at a given moment, then the computation can make 
a step and change its state to $t'$. The evaluation relation 
is defined using a set of inference rules (axioms and proper rules). 
\end{shadequote}

\end{frame}


\begin{frame}
\begin{definition}{Normal Form}
A term $t$ is in normal form if no evaluation rule 
applies to it---i.e., if there is no $t'$ such that 
$t \rightarrow t'$. \pause Every value is in normal 
form. \pause Normal forms that are not values represent 
that something went wrong.  
\end{definition}
\end{frame}
\begin{frame}
\frametitle{Axioms (computation rules)} 

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (E-PredZero)}
\UnaryInfC{$pred\ 0 \rightarrow 0$}
\end{prooftree} 

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (E-PredSucc)}
\UnaryInfC{$pred(succ\ t_1) \rightarrow t_1$}
\end{prooftree} 


\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (E-IsZeroZero)}
\UnaryInfC{$iszero\ 0 \rightarrow true$}
\end{prooftree} 

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (E-IsZeroSucc)}
\UnaryInfC{$iszero(succ\ t_1) \rightarrow false$}
\end{prooftree} 

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (E-IfTrue)}
\UnaryInfC{$if\ true\ then\ t_1\ else\ t_2 \rightarrow t_1$} 
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{\quad (E-IfFalse)}
\UnaryInfC{$if\ false\ then\ t_1\ else\ t_2 \rightarrow t_2$}
\end{prooftree}

\end{frame}

\begin{frame}
\frametitle{Proper rules (congruence rules)} 

\begin{prooftree}
\AxiomC{$t_1 \rightarrow t_1'$}
\RightLabel{\quad (E-If)}
\UnaryInfC{$if\ t_1\ then\ t_2\ else\ t_3 \rightarrow if\ t_1' \ then\ t_2\ else\ t_3$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_1 \rightarrow t_1'$}
\RightLabel{\quad (E-Succ)}
\UnaryInfC{$succ\ t_1\ \rightarrow succ\ t_1'$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_1 \rightarrow t_1'$}
\RightLabel{\quad (E-Pred)}
\UnaryInfC{$pred\ t_1\ \rightarrow pred\ t_1'$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t_1 \rightarrow t_1'$}
\RightLabel{\quad (E-IsZero)}
\UnaryInfC{$iszero\ t_1\ \rightarrow iszero\ t_1'$}
\end{prooftree}
\end{frame}


\begin{frame}
Let's code the Untyped Arithmetic Expressions in Haskell \ldots
\end{frame}
\end{document}
